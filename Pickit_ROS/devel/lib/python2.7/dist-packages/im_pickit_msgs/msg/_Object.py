# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from im_pickit_msgs/Object.msg. Do not edit."""
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct

import geometry_msgs.msg
import im_pickit_msgs.msg
import std_msgs.msg

class Object(genpy.Message):
  _md5sum = "f2b8ba1b2df980f0868c9ec736119a65"
  _type = "im_pickit_msgs/Object"
  _has_header = False #flag to mark the presence of a Header object
  _full_text = """## Copyright Intermodalics 2016
## This message contains all descriptive data for one object found by Pick-it ##

# Object index in list associated to a single detection run.
uint16                                  index

# Object frame expressed with respect to a frame.
geometry_msgs/TransformStamped          object_tf

# Object pick frame expressed with respect to a frame.
geometry_msgs/TransformStamped          object_pick_tf

# Object model used for registration, reliability score calculation and more.
ObjectModel                             model

# Number of scene points verifying the object model.
uint16                                  n_points

# Object dimensions. The contents of the x, y and z elements depend on the
# object type:
#
#  |   Type      |    X     |    Y     |    Z     |
#  |-------------|----------|----------|----------|
#  | CYLINDER    | length   | diameter | diameter |
#  | SPHERE      | diameter | diameter | diameter |
#  | RECTANGLE   | length   | width    |    0     |
#  | SQUARE      | length   | length   |    0     |
#  | ELLIPSE     | length   | width    |    0     |
#  | CIRCLE      | diameter | diameter |    0     |
#  | POINT_CLOUD | bbox X   | bbox Y   | bbox Z   |
#  | BLOB        | bbox X   | bbox Y   | bbox Z   |
#
# where 'bbox X' means the span of the object's bounding box along the X-axis.
geometry_msgs/Vector3                   dimensions

# Contains scoring metrics used to quantify the goodness of a detection.
Reliability                             reliability

# NOTE: There is currently an inconsistency between terms used in the
#       back-end vs. the front-end. The following table summarizes them to
#       prevent confusion:
#
#       BACK-END flag  maps to ->   FRONT-END detection grid column
#
#       is_pickable    maps to ->   Pickable
#       is_detectable  maps to ->   Valid
#       is_valid       maps to ->   <None>
#
#       Notice in particular how the is_valid back-end flag and the Valid
#       front-end detection grid column have different meanings.

# Flag that evaluates to true when an object is both pickable and detectable.
bool                                    is_valid

# Flag that evaluates to true when an object satisfies frame alignment and
# collision constraints.
bool                                    is_pickable

# Flag that evaluates to true when an object satisfies fitting, reliability and
# size constraints.
bool                                    is_detectable

# List of strings describing main detection status for invalid detections
# (e.g. ERROR, INVALID, UNPICKABLE).
# See CATEGORY strings in StatusXxx.msg files for available categories.
# The list is empty in case of a valid detection.
string[]                                categories

# List of substatus identifiers providing detail information for each of the
# above categories. There is one substatus per category.
# The list is empty in case of a valid detection.
SubStatus[]                             substatuses

================================================================================
MSG: geometry_msgs/TransformStamped
# This expresses a transform from coordinate frame header.frame_id
# to the coordinate frame child_frame_id
#
# This message is mostly used by the 
# <a href="http://wiki.ros.org/tf">tf</a> package. 
# See its documentation for more information.

Header header
string child_frame_id # the frame id of the child frame
Transform transform

================================================================================
MSG: std_msgs/Header
# Standard metadata for higher-level stamped data types.
# This is generally used to communicate timestamped data 
# in a particular coordinate frame.
# 
# sequence ID: consecutively increasing ID 
uint32 seq
#Two-integer timestamp that is expressed as:
# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')
# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')
# time-handling sugar is provided by the client library
time stamp
#Frame this data is associated with
# 0: no frame
# 1: global frame
string frame_id

================================================================================
MSG: geometry_msgs/Transform
# This represents the transform between two coordinate frames in free space.

Vector3 translation
Quaternion rotation

================================================================================
MSG: geometry_msgs/Vector3
# This represents a vector in free space. 
# It is only meant to represent a direction. Therefore, it does not
# make sense to apply a translation to it (e.g., when applying a 
# generic rigid transformation to a Vector3, tf2 will only apply the
# rotation). If you want your data to be translatable too, use the
# geometry_msgs/Point message instead.

float64 x
float64 y
float64 z
================================================================================
MSG: geometry_msgs/Quaternion
# This represents an orientation in free space in quaternion form.

float64 x
float64 y
float64 z
float64 w

================================================================================
MSG: im_pickit_msgs/ObjectModel
# Copyright (c) 2017, Pick-it NV.
# All rights reserved.

# Definition of different object models used for registration, reliability score calculation and more.

# Unspecified
uint8 NONE          = 0

# 2D models:
uint8 SQUARE        = 21
uint8 RECTANGLE     = 22
uint8 CIRCLE        = 23
uint8 ELLIPSE       = 24

# 3D models:
uint8 CYLINDER      = 32
uint8 SPHERE        = 33
uint8 POINT_CLOUD   = 35  # Object model given as point cloud (Pickit-Teach).

# Other models:
uint8 BLOB          = 50  # Object without specified shape -> No object fitting is performed.

# Models of internal use only:
uint8 CLUSTER       = 250

uint8 type  # Model type, takes one of the above defined models types as value.

================================================================================
MSG: im_pickit_msgs/Reliability
## Contains all parameters describing reliability of detected object
## Values expressed as confidence levels ranging from 0.0 to 1.0

## Ratio of inlier points close to the border of the "Intermodalics hole" and
## all points of the "Intermodalics hole".
ReliabilityValue scene_coverage_2d

## Ratio of inlier points to all points in the cluster.
ReliabilityValue scene_coverage_3d

### TODO(@wannesvanloock): Add description pls.
ReliabilityValue model_contour_coverage_2d
### TODO(@wannesvanloock): Add description pls.
ReliabilityValue model_surface_coverage_2d

## 3D reliability of the matched model
ReliabilityValue model_coverage_3d

================================================================================
MSG: im_pickit_msgs/ReliabilityValue
float64 value
float64 required_value

# mostly we work with lower limits so usually this is false
bool has_upper_limit     
================================================================================
MSG: im_pickit_msgs/SubStatus
# Rejected object substatus:
#  - StatusUnpickable (orange)
#  - StatusInvalid (red)
#  - StatusDiscarded (no marker)

uint16 substatus
string detail
"""
  __slots__ = ['index','object_tf','object_pick_tf','model','n_points','dimensions','reliability','is_valid','is_pickable','is_detectable','categories','substatuses']
  _slot_types = ['uint16','geometry_msgs/TransformStamped','geometry_msgs/TransformStamped','im_pickit_msgs/ObjectModel','uint16','geometry_msgs/Vector3','im_pickit_msgs/Reliability','bool','bool','bool','string[]','im_pickit_msgs/SubStatus[]']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       index,object_tf,object_pick_tf,model,n_points,dimensions,reliability,is_valid,is_pickable,is_detectable,categories,substatuses

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(Object, self).__init__(*args, **kwds)
      #message fields cannot be None, assign default values for those that are
      if self.index is None:
        self.index = 0
      if self.object_tf is None:
        self.object_tf = geometry_msgs.msg.TransformStamped()
      if self.object_pick_tf is None:
        self.object_pick_tf = geometry_msgs.msg.TransformStamped()
      if self.model is None:
        self.model = im_pickit_msgs.msg.ObjectModel()
      if self.n_points is None:
        self.n_points = 0
      if self.dimensions is None:
        self.dimensions = geometry_msgs.msg.Vector3()
      if self.reliability is None:
        self.reliability = im_pickit_msgs.msg.Reliability()
      if self.is_valid is None:
        self.is_valid = False
      if self.is_pickable is None:
        self.is_pickable = False
      if self.is_detectable is None:
        self.is_detectable = False
      if self.categories is None:
        self.categories = []
      if self.substatuses is None:
        self.substatuses = []
    else:
      self.index = 0
      self.object_tf = geometry_msgs.msg.TransformStamped()
      self.object_pick_tf = geometry_msgs.msg.TransformStamped()
      self.model = im_pickit_msgs.msg.ObjectModel()
      self.n_points = 0
      self.dimensions = geometry_msgs.msg.Vector3()
      self.reliability = im_pickit_msgs.msg.Reliability()
      self.is_valid = False
      self.is_pickable = False
      self.is_detectable = False
      self.categories = []
      self.substatuses = []

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self
      buff.write(_get_struct_H3I().pack(_x.index, _x.object_tf.header.seq, _x.object_tf.header.stamp.secs, _x.object_tf.header.stamp.nsecs))
      _x = self.object_tf.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.object_tf.child_frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_get_struct_7d3I().pack(_x.object_tf.transform.translation.x, _x.object_tf.transform.translation.y, _x.object_tf.transform.translation.z, _x.object_tf.transform.rotation.x, _x.object_tf.transform.rotation.y, _x.object_tf.transform.rotation.z, _x.object_tf.transform.rotation.w, _x.object_pick_tf.header.seq, _x.object_pick_tf.header.stamp.secs, _x.object_pick_tf.header.stamp.nsecs))
      _x = self.object_pick_tf.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.object_pick_tf.child_frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_get_struct_7dBH5dB2dB2dB2dB2d4B().pack(_x.object_pick_tf.transform.translation.x, _x.object_pick_tf.transform.translation.y, _x.object_pick_tf.transform.translation.z, _x.object_pick_tf.transform.rotation.x, _x.object_pick_tf.transform.rotation.y, _x.object_pick_tf.transform.rotation.z, _x.object_pick_tf.transform.rotation.w, _x.model.type, _x.n_points, _x.dimensions.x, _x.dimensions.y, _x.dimensions.z, _x.reliability.scene_coverage_2d.value, _x.reliability.scene_coverage_2d.required_value, _x.reliability.scene_coverage_2d.has_upper_limit, _x.reliability.scene_coverage_3d.value, _x.reliability.scene_coverage_3d.required_value, _x.reliability.scene_coverage_3d.has_upper_limit, _x.reliability.model_contour_coverage_2d.value, _x.reliability.model_contour_coverage_2d.required_value, _x.reliability.model_contour_coverage_2d.has_upper_limit, _x.reliability.model_surface_coverage_2d.value, _x.reliability.model_surface_coverage_2d.required_value, _x.reliability.model_surface_coverage_2d.has_upper_limit, _x.reliability.model_coverage_3d.value, _x.reliability.model_coverage_3d.required_value, _x.reliability.model_coverage_3d.has_upper_limit, _x.is_valid, _x.is_pickable, _x.is_detectable))
      length = len(self.categories)
      buff.write(_struct_I.pack(length))
      for val1 in self.categories:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.pack('<I%ss'%length, length, val1))
      length = len(self.substatuses)
      buff.write(_struct_I.pack(length))
      for val1 in self.substatuses:
        buff.write(_get_struct_H().pack(val1.substatus))
        _x = val1.detail
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.pack('<I%ss'%length, length, _x))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    try:
      if self.object_tf is None:
        self.object_tf = geometry_msgs.msg.TransformStamped()
      if self.object_pick_tf is None:
        self.object_pick_tf = geometry_msgs.msg.TransformStamped()
      if self.model is None:
        self.model = im_pickit_msgs.msg.ObjectModel()
      if self.dimensions is None:
        self.dimensions = geometry_msgs.msg.Vector3()
      if self.reliability is None:
        self.reliability = im_pickit_msgs.msg.Reliability()
      if self.substatuses is None:
        self.substatuses = None
      end = 0
      _x = self
      start = end
      end += 14
      (_x.index, _x.object_tf.header.seq, _x.object_tf.header.stamp.secs, _x.object_tf.header.stamp.nsecs,) = _get_struct_H3I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.object_tf.header.frame_id = str[start:end].decode('utf-8')
      else:
        self.object_tf.header.frame_id = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.object_tf.child_frame_id = str[start:end].decode('utf-8')
      else:
        self.object_tf.child_frame_id = str[start:end]
      _x = self
      start = end
      end += 68
      (_x.object_tf.transform.translation.x, _x.object_tf.transform.translation.y, _x.object_tf.transform.translation.z, _x.object_tf.transform.rotation.x, _x.object_tf.transform.rotation.y, _x.object_tf.transform.rotation.z, _x.object_tf.transform.rotation.w, _x.object_pick_tf.header.seq, _x.object_pick_tf.header.stamp.secs, _x.object_pick_tf.header.stamp.nsecs,) = _get_struct_7d3I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.object_pick_tf.header.frame_id = str[start:end].decode('utf-8')
      else:
        self.object_pick_tf.header.frame_id = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.object_pick_tf.child_frame_id = str[start:end].decode('utf-8')
      else:
        self.object_pick_tf.child_frame_id = str[start:end]
      _x = self
      start = end
      end += 171
      (_x.object_pick_tf.transform.translation.x, _x.object_pick_tf.transform.translation.y, _x.object_pick_tf.transform.translation.z, _x.object_pick_tf.transform.rotation.x, _x.object_pick_tf.transform.rotation.y, _x.object_pick_tf.transform.rotation.z, _x.object_pick_tf.transform.rotation.w, _x.model.type, _x.n_points, _x.dimensions.x, _x.dimensions.y, _x.dimensions.z, _x.reliability.scene_coverage_2d.value, _x.reliability.scene_coverage_2d.required_value, _x.reliability.scene_coverage_2d.has_upper_limit, _x.reliability.scene_coverage_3d.value, _x.reliability.scene_coverage_3d.required_value, _x.reliability.scene_coverage_3d.has_upper_limit, _x.reliability.model_contour_coverage_2d.value, _x.reliability.model_contour_coverage_2d.required_value, _x.reliability.model_contour_coverage_2d.has_upper_limit, _x.reliability.model_surface_coverage_2d.value, _x.reliability.model_surface_coverage_2d.required_value, _x.reliability.model_surface_coverage_2d.has_upper_limit, _x.reliability.model_coverage_3d.value, _x.reliability.model_coverage_3d.required_value, _x.reliability.model_coverage_3d.has_upper_limit, _x.is_valid, _x.is_pickable, _x.is_detectable,) = _get_struct_7dBH5dB2dB2dB2dB2d4B().unpack(str[start:end])
      self.reliability.scene_coverage_2d.has_upper_limit = bool(self.reliability.scene_coverage_2d.has_upper_limit)
      self.reliability.scene_coverage_3d.has_upper_limit = bool(self.reliability.scene_coverage_3d.has_upper_limit)
      self.reliability.model_contour_coverage_2d.has_upper_limit = bool(self.reliability.model_contour_coverage_2d.has_upper_limit)
      self.reliability.model_surface_coverage_2d.has_upper_limit = bool(self.reliability.model_surface_coverage_2d.has_upper_limit)
      self.reliability.model_coverage_3d.has_upper_limit = bool(self.reliability.model_coverage_3d.has_upper_limit)
      self.is_valid = bool(self.is_valid)
      self.is_pickable = bool(self.is_pickable)
      self.is_detectable = bool(self.is_detectable)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.categories = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8')
        else:
          val1 = str[start:end]
        self.categories.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.substatuses = []
      for i in range(0, length):
        val1 = im_pickit_msgs.msg.SubStatus()
        start = end
        end += 2
        (val1.substatus,) = _get_struct_H().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.detail = str[start:end].decode('utf-8')
        else:
          val1.detail = str[start:end]
        self.substatuses.append(val1)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e) #most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self
      buff.write(_get_struct_H3I().pack(_x.index, _x.object_tf.header.seq, _x.object_tf.header.stamp.secs, _x.object_tf.header.stamp.nsecs))
      _x = self.object_tf.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.object_tf.child_frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_get_struct_7d3I().pack(_x.object_tf.transform.translation.x, _x.object_tf.transform.translation.y, _x.object_tf.transform.translation.z, _x.object_tf.transform.rotation.x, _x.object_tf.transform.rotation.y, _x.object_tf.transform.rotation.z, _x.object_tf.transform.rotation.w, _x.object_pick_tf.header.seq, _x.object_pick_tf.header.stamp.secs, _x.object_pick_tf.header.stamp.nsecs))
      _x = self.object_pick_tf.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.object_pick_tf.child_frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_get_struct_7dBH5dB2dB2dB2dB2d4B().pack(_x.object_pick_tf.transform.translation.x, _x.object_pick_tf.transform.translation.y, _x.object_pick_tf.transform.translation.z, _x.object_pick_tf.transform.rotation.x, _x.object_pick_tf.transform.rotation.y, _x.object_pick_tf.transform.rotation.z, _x.object_pick_tf.transform.rotation.w, _x.model.type, _x.n_points, _x.dimensions.x, _x.dimensions.y, _x.dimensions.z, _x.reliability.scene_coverage_2d.value, _x.reliability.scene_coverage_2d.required_value, _x.reliability.scene_coverage_2d.has_upper_limit, _x.reliability.scene_coverage_3d.value, _x.reliability.scene_coverage_3d.required_value, _x.reliability.scene_coverage_3d.has_upper_limit, _x.reliability.model_contour_coverage_2d.value, _x.reliability.model_contour_coverage_2d.required_value, _x.reliability.model_contour_coverage_2d.has_upper_limit, _x.reliability.model_surface_coverage_2d.value, _x.reliability.model_surface_coverage_2d.required_value, _x.reliability.model_surface_coverage_2d.has_upper_limit, _x.reliability.model_coverage_3d.value, _x.reliability.model_coverage_3d.required_value, _x.reliability.model_coverage_3d.has_upper_limit, _x.is_valid, _x.is_pickable, _x.is_detectable))
      length = len(self.categories)
      buff.write(_struct_I.pack(length))
      for val1 in self.categories:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.pack('<I%ss'%length, length, val1))
      length = len(self.substatuses)
      buff.write(_struct_I.pack(length))
      for val1 in self.substatuses:
        buff.write(_get_struct_H().pack(val1.substatus))
        _x = val1.detail
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.pack('<I%ss'%length, length, _x))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    try:
      if self.object_tf is None:
        self.object_tf = geometry_msgs.msg.TransformStamped()
      if self.object_pick_tf is None:
        self.object_pick_tf = geometry_msgs.msg.TransformStamped()
      if self.model is None:
        self.model = im_pickit_msgs.msg.ObjectModel()
      if self.dimensions is None:
        self.dimensions = geometry_msgs.msg.Vector3()
      if self.reliability is None:
        self.reliability = im_pickit_msgs.msg.Reliability()
      if self.substatuses is None:
        self.substatuses = None
      end = 0
      _x = self
      start = end
      end += 14
      (_x.index, _x.object_tf.header.seq, _x.object_tf.header.stamp.secs, _x.object_tf.header.stamp.nsecs,) = _get_struct_H3I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.object_tf.header.frame_id = str[start:end].decode('utf-8')
      else:
        self.object_tf.header.frame_id = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.object_tf.child_frame_id = str[start:end].decode('utf-8')
      else:
        self.object_tf.child_frame_id = str[start:end]
      _x = self
      start = end
      end += 68
      (_x.object_tf.transform.translation.x, _x.object_tf.transform.translation.y, _x.object_tf.transform.translation.z, _x.object_tf.transform.rotation.x, _x.object_tf.transform.rotation.y, _x.object_tf.transform.rotation.z, _x.object_tf.transform.rotation.w, _x.object_pick_tf.header.seq, _x.object_pick_tf.header.stamp.secs, _x.object_pick_tf.header.stamp.nsecs,) = _get_struct_7d3I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.object_pick_tf.header.frame_id = str[start:end].decode('utf-8')
      else:
        self.object_pick_tf.header.frame_id = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.object_pick_tf.child_frame_id = str[start:end].decode('utf-8')
      else:
        self.object_pick_tf.child_frame_id = str[start:end]
      _x = self
      start = end
      end += 171
      (_x.object_pick_tf.transform.translation.x, _x.object_pick_tf.transform.translation.y, _x.object_pick_tf.transform.translation.z, _x.object_pick_tf.transform.rotation.x, _x.object_pick_tf.transform.rotation.y, _x.object_pick_tf.transform.rotation.z, _x.object_pick_tf.transform.rotation.w, _x.model.type, _x.n_points, _x.dimensions.x, _x.dimensions.y, _x.dimensions.z, _x.reliability.scene_coverage_2d.value, _x.reliability.scene_coverage_2d.required_value, _x.reliability.scene_coverage_2d.has_upper_limit, _x.reliability.scene_coverage_3d.value, _x.reliability.scene_coverage_3d.required_value, _x.reliability.scene_coverage_3d.has_upper_limit, _x.reliability.model_contour_coverage_2d.value, _x.reliability.model_contour_coverage_2d.required_value, _x.reliability.model_contour_coverage_2d.has_upper_limit, _x.reliability.model_surface_coverage_2d.value, _x.reliability.model_surface_coverage_2d.required_value, _x.reliability.model_surface_coverage_2d.has_upper_limit, _x.reliability.model_coverage_3d.value, _x.reliability.model_coverage_3d.required_value, _x.reliability.model_coverage_3d.has_upper_limit, _x.is_valid, _x.is_pickable, _x.is_detectable,) = _get_struct_7dBH5dB2dB2dB2dB2d4B().unpack(str[start:end])
      self.reliability.scene_coverage_2d.has_upper_limit = bool(self.reliability.scene_coverage_2d.has_upper_limit)
      self.reliability.scene_coverage_3d.has_upper_limit = bool(self.reliability.scene_coverage_3d.has_upper_limit)
      self.reliability.model_contour_coverage_2d.has_upper_limit = bool(self.reliability.model_contour_coverage_2d.has_upper_limit)
      self.reliability.model_surface_coverage_2d.has_upper_limit = bool(self.reliability.model_surface_coverage_2d.has_upper_limit)
      self.reliability.model_coverage_3d.has_upper_limit = bool(self.reliability.model_coverage_3d.has_upper_limit)
      self.is_valid = bool(self.is_valid)
      self.is_pickable = bool(self.is_pickable)
      self.is_detectable = bool(self.is_detectable)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.categories = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8')
        else:
          val1 = str[start:end]
        self.categories.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.substatuses = []
      for i in range(0, length):
        val1 = im_pickit_msgs.msg.SubStatus()
        start = end
        end += 2
        (val1.substatus,) = _get_struct_H().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.detail = str[start:end].decode('utf-8')
        else:
          val1.detail = str[start:end]
        self.substatuses.append(val1)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e) #most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_H = None
def _get_struct_H():
    global _struct_H
    if _struct_H is None:
        _struct_H = struct.Struct("<H")
    return _struct_H
_struct_7dBH5dB2dB2dB2dB2d4B = None
def _get_struct_7dBH5dB2dB2dB2dB2d4B():
    global _struct_7dBH5dB2dB2dB2dB2d4B
    if _struct_7dBH5dB2dB2dB2dB2d4B is None:
        _struct_7dBH5dB2dB2dB2dB2d4B = struct.Struct("<7dBH5dB2dB2dB2dB2d4B")
    return _struct_7dBH5dB2dB2dB2dB2d4B
_struct_H3I = None
def _get_struct_H3I():
    global _struct_H3I
    if _struct_H3I is None:
        _struct_H3I = struct.Struct("<H3I")
    return _struct_H3I
_struct_7d3I = None
def _get_struct_7d3I():
    global _struct_7d3I
    if _struct_7d3I is None:
        _struct_7d3I = struct.Struct("<7d3I")
    return _struct_7d3I
