# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from im_pickit_msgs/ObjectArray.msg. Do not edit."""
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct

import geometry_msgs.msg
import im_pickit_msgs.msg
import std_msgs.msg

class ObjectArray(genpy.Message):
  _md5sum = "204d3d08d5381f80541e760fbffe322f"
  _type = "im_pickit_msgs/ObjectArray"
  _has_header = True #flag to mark the presence of a Header object
  _full_text = """## Copyright Intermodalics 2014
## This message contains all objects found by the last Pick-it run ##

# Origin of the msg content
uint8 NEW_OBJECT_DETECTION = 2
uint8 RESET = 0

# Clustering methods
uint8 NO_CLUSTERING = 10
uint8 DISTANCE_BASED_CLUSTERING = 11
uint8 NORMAL_BASED_CLUSTERING = 12

std_msgs/Header                 header
uint8                           content
uint32                          encoder_stamp
geometry_msgs/TransformStamped  robot_to_camera_tf
geometry_msgs/TransformStamped  camera_to_reference_tf

float64                         cloud_capturing_duration

uint8                           clustering_method
uint16                          n_rejected_clusters
float64                         clustering_duration

float64                         calculation_time # Total object detection time

uint16                          n_valid_objects
uint16                          n_rejected_objects

im_pickit_msgs/Object[]         objects

================================================================================
MSG: std_msgs/Header
# Standard metadata for higher-level stamped data types.
# This is generally used to communicate timestamped data 
# in a particular coordinate frame.
# 
# sequence ID: consecutively increasing ID 
uint32 seq
#Two-integer timestamp that is expressed as:
# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')
# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')
# time-handling sugar is provided by the client library
time stamp
#Frame this data is associated with
# 0: no frame
# 1: global frame
string frame_id

================================================================================
MSG: geometry_msgs/TransformStamped
# This expresses a transform from coordinate frame header.frame_id
# to the coordinate frame child_frame_id
#
# This message is mostly used by the 
# <a href="http://wiki.ros.org/tf">tf</a> package. 
# See its documentation for more information.

Header header
string child_frame_id # the frame id of the child frame
Transform transform

================================================================================
MSG: geometry_msgs/Transform
# This represents the transform between two coordinate frames in free space.

Vector3 translation
Quaternion rotation

================================================================================
MSG: geometry_msgs/Vector3
# This represents a vector in free space. 
# It is only meant to represent a direction. Therefore, it does not
# make sense to apply a translation to it (e.g., when applying a 
# generic rigid transformation to a Vector3, tf2 will only apply the
# rotation). If you want your data to be translatable too, use the
# geometry_msgs/Point message instead.

float64 x
float64 y
float64 z
================================================================================
MSG: geometry_msgs/Quaternion
# This represents an orientation in free space in quaternion form.

float64 x
float64 y
float64 z
float64 w

================================================================================
MSG: im_pickit_msgs/Object
## Copyright Intermodalics 2016
## This message contains all descriptive data for one object found by Pick-it ##

# Object index in list associated to a single detection run.
uint16                                  index

# Object frame expressed with respect to a frame.
geometry_msgs/TransformStamped          object_tf

# Object pick frame expressed with respect to a frame.
geometry_msgs/TransformStamped          object_pick_tf

# Object model used for registration, reliability score calculation and more.
ObjectModel                             model

# Number of scene points verifying the object model.
uint16                                  n_points

# Object dimensions. The contents of the x, y and z elements depend on the
# object type:
#
#  |   Type      |    X     |    Y     |    Z     |
#  |-------------|----------|----------|----------|
#  | CYLINDER    | length   | diameter | diameter |
#  | SPHERE      | diameter | diameter | diameter |
#  | RECTANGLE   | length   | width    |    0     |
#  | SQUARE      | length   | length   |    0     |
#  | ELLIPSE     | length   | width    |    0     |
#  | CIRCLE      | diameter | diameter |    0     |
#  | POINT_CLOUD | bbox X   | bbox Y   | bbox Z   |
#  | BLOB        | bbox X   | bbox Y   | bbox Z   |
#
# where 'bbox X' means the span of the object's bounding box along the X-axis.
geometry_msgs/Vector3                   dimensions

# Contains scoring metrics used to quantify the goodness of a detection.
Reliability                             reliability

# NOTE: There is currently an inconsistency between terms used in the
#       back-end vs. the front-end. The following table summarizes them to
#       prevent confusion:
#
#       BACK-END flag  maps to ->   FRONT-END detection grid column
#
#       is_pickable    maps to ->   Pickable
#       is_detectable  maps to ->   Valid
#       is_valid       maps to ->   <None>
#
#       Notice in particular how the is_valid back-end flag and the Valid
#       front-end detection grid column have different meanings.

# Flag that evaluates to true when an object is both pickable and detectable.
bool                                    is_valid

# Flag that evaluates to true when an object satisfies frame alignment and
# collision constraints.
bool                                    is_pickable

# Flag that evaluates to true when an object satisfies fitting, reliability and
# size constraints.
bool                                    is_detectable

# List of strings describing main detection status for invalid detections
# (e.g. ERROR, INVALID, UNPICKABLE).
# See CATEGORY strings in StatusXxx.msg files for available categories.
# The list is empty in case of a valid detection.
string[]                                categories

# List of substatus identifiers providing detail information for each of the
# above categories. There is one substatus per category.
# The list is empty in case of a valid detection.
SubStatus[]                             substatuses

================================================================================
MSG: im_pickit_msgs/ObjectModel
# Copyright (c) 2017, Pick-it NV.
# All rights reserved.

# Definition of different object models used for registration, reliability score calculation and more.

# Unspecified
uint8 NONE          = 0

# 2D models:
uint8 SQUARE        = 21
uint8 RECTANGLE     = 22
uint8 CIRCLE        = 23
uint8 ELLIPSE       = 24

# 3D models:
uint8 CYLINDER      = 32
uint8 SPHERE        = 33
uint8 POINT_CLOUD   = 35  # Object model given as point cloud (Pickit-Teach).

# Other models:
uint8 BLOB          = 50  # Object without specified shape -> No object fitting is performed.

# Models of internal use only:
uint8 CLUSTER       = 250

uint8 type  # Model type, takes one of the above defined models types as value.

================================================================================
MSG: im_pickit_msgs/Reliability
## Contains all parameters describing reliability of detected object
## Values expressed as confidence levels ranging from 0.0 to 1.0

## Ratio of inlier points close to the border of the "Intermodalics hole" and
## all points of the "Intermodalics hole".
ReliabilityValue scene_coverage_2d

## Ratio of inlier points to all points in the cluster.
ReliabilityValue scene_coverage_3d

### TODO(@wannesvanloock): Add description pls.
ReliabilityValue model_contour_coverage_2d
### TODO(@wannesvanloock): Add description pls.
ReliabilityValue model_surface_coverage_2d

## 3D reliability of the matched model
ReliabilityValue model_coverage_3d

================================================================================
MSG: im_pickit_msgs/ReliabilityValue
float64 value
float64 required_value

# mostly we work with lower limits so usually this is false
bool has_upper_limit     
================================================================================
MSG: im_pickit_msgs/SubStatus
# Rejected object substatus:
#  - StatusUnpickable (orange)
#  - StatusInvalid (red)
#  - StatusDiscarded (no marker)

uint16 substatus
string detail
"""
  # Pseudo-constants
  NEW_OBJECT_DETECTION = 2
  RESET = 0
  NO_CLUSTERING = 10
  DISTANCE_BASED_CLUSTERING = 11
  NORMAL_BASED_CLUSTERING = 12

  __slots__ = ['header','content','encoder_stamp','robot_to_camera_tf','camera_to_reference_tf','cloud_capturing_duration','clustering_method','n_rejected_clusters','clustering_duration','calculation_time','n_valid_objects','n_rejected_objects','objects']
  _slot_types = ['std_msgs/Header','uint8','uint32','geometry_msgs/TransformStamped','geometry_msgs/TransformStamped','float64','uint8','uint16','float64','float64','uint16','uint16','im_pickit_msgs/Object[]']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       header,content,encoder_stamp,robot_to_camera_tf,camera_to_reference_tf,cloud_capturing_duration,clustering_method,n_rejected_clusters,clustering_duration,calculation_time,n_valid_objects,n_rejected_objects,objects

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(ObjectArray, self).__init__(*args, **kwds)
      #message fields cannot be None, assign default values for those that are
      if self.header is None:
        self.header = std_msgs.msg.Header()
      if self.content is None:
        self.content = 0
      if self.encoder_stamp is None:
        self.encoder_stamp = 0
      if self.robot_to_camera_tf is None:
        self.robot_to_camera_tf = geometry_msgs.msg.TransformStamped()
      if self.camera_to_reference_tf is None:
        self.camera_to_reference_tf = geometry_msgs.msg.TransformStamped()
      if self.cloud_capturing_duration is None:
        self.cloud_capturing_duration = 0.
      if self.clustering_method is None:
        self.clustering_method = 0
      if self.n_rejected_clusters is None:
        self.n_rejected_clusters = 0
      if self.clustering_duration is None:
        self.clustering_duration = 0.
      if self.calculation_time is None:
        self.calculation_time = 0.
      if self.n_valid_objects is None:
        self.n_valid_objects = 0
      if self.n_rejected_objects is None:
        self.n_rejected_objects = 0
      if self.objects is None:
        self.objects = []
    else:
      self.header = std_msgs.msg.Header()
      self.content = 0
      self.encoder_stamp = 0
      self.robot_to_camera_tf = geometry_msgs.msg.TransformStamped()
      self.camera_to_reference_tf = geometry_msgs.msg.TransformStamped()
      self.cloud_capturing_duration = 0.
      self.clustering_method = 0
      self.n_rejected_clusters = 0
      self.clustering_duration = 0.
      self.calculation_time = 0.
      self.n_valid_objects = 0
      self.n_rejected_objects = 0
      self.objects = []

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self
      buff.write(_get_struct_3I().pack(_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs))
      _x = self.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_get_struct_B4I().pack(_x.content, _x.encoder_stamp, _x.robot_to_camera_tf.header.seq, _x.robot_to_camera_tf.header.stamp.secs, _x.robot_to_camera_tf.header.stamp.nsecs))
      _x = self.robot_to_camera_tf.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.robot_to_camera_tf.child_frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_get_struct_7d3I().pack(_x.robot_to_camera_tf.transform.translation.x, _x.robot_to_camera_tf.transform.translation.y, _x.robot_to_camera_tf.transform.translation.z, _x.robot_to_camera_tf.transform.rotation.x, _x.robot_to_camera_tf.transform.rotation.y, _x.robot_to_camera_tf.transform.rotation.z, _x.robot_to_camera_tf.transform.rotation.w, _x.camera_to_reference_tf.header.seq, _x.camera_to_reference_tf.header.stamp.secs, _x.camera_to_reference_tf.header.stamp.nsecs))
      _x = self.camera_to_reference_tf.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.camera_to_reference_tf.child_frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_get_struct_8dBH2d2H().pack(_x.camera_to_reference_tf.transform.translation.x, _x.camera_to_reference_tf.transform.translation.y, _x.camera_to_reference_tf.transform.translation.z, _x.camera_to_reference_tf.transform.rotation.x, _x.camera_to_reference_tf.transform.rotation.y, _x.camera_to_reference_tf.transform.rotation.z, _x.camera_to_reference_tf.transform.rotation.w, _x.cloud_capturing_duration, _x.clustering_method, _x.n_rejected_clusters, _x.clustering_duration, _x.calculation_time, _x.n_valid_objects, _x.n_rejected_objects))
      length = len(self.objects)
      buff.write(_struct_I.pack(length))
      for val1 in self.objects:
        buff.write(_get_struct_H().pack(val1.index))
        _v1 = val1.object_tf
        _v2 = _v1.header
        buff.write(_get_struct_I().pack(_v2.seq))
        _v3 = _v2.stamp
        _x = _v3
        buff.write(_get_struct_2I().pack(_x.secs, _x.nsecs))
        _x = _v2.frame_id
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = _v1.child_frame_id
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.pack('<I%ss'%length, length, _x))
        _v4 = _v1.transform
        _v5 = _v4.translation
        _x = _v5
        buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
        _v6 = _v4.rotation
        _x = _v6
        buff.write(_get_struct_4d().pack(_x.x, _x.y, _x.z, _x.w))
        _v7 = val1.object_pick_tf
        _v8 = _v7.header
        buff.write(_get_struct_I().pack(_v8.seq))
        _v9 = _v8.stamp
        _x = _v9
        buff.write(_get_struct_2I().pack(_x.secs, _x.nsecs))
        _x = _v8.frame_id
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = _v7.child_frame_id
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.pack('<I%ss'%length, length, _x))
        _v10 = _v7.transform
        _v11 = _v10.translation
        _x = _v11
        buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
        _v12 = _v10.rotation
        _x = _v12
        buff.write(_get_struct_4d().pack(_x.x, _x.y, _x.z, _x.w))
        _v13 = val1.model
        buff.write(_get_struct_B().pack(_v13.type))
        buff.write(_get_struct_H().pack(val1.n_points))
        _v14 = val1.dimensions
        _x = _v14
        buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
        _v15 = val1.reliability
        _v16 = _v15.scene_coverage_2d
        _x = _v16
        buff.write(_get_struct_2dB().pack(_x.value, _x.required_value, _x.has_upper_limit))
        _v17 = _v15.scene_coverage_3d
        _x = _v17
        buff.write(_get_struct_2dB().pack(_x.value, _x.required_value, _x.has_upper_limit))
        _v18 = _v15.model_contour_coverage_2d
        _x = _v18
        buff.write(_get_struct_2dB().pack(_x.value, _x.required_value, _x.has_upper_limit))
        _v19 = _v15.model_surface_coverage_2d
        _x = _v19
        buff.write(_get_struct_2dB().pack(_x.value, _x.required_value, _x.has_upper_limit))
        _v20 = _v15.model_coverage_3d
        _x = _v20
        buff.write(_get_struct_2dB().pack(_x.value, _x.required_value, _x.has_upper_limit))
        _x = val1
        buff.write(_get_struct_3B().pack(_x.is_valid, _x.is_pickable, _x.is_detectable))
        length = len(val1.categories)
        buff.write(_struct_I.pack(length))
        for val2 in val1.categories:
          length = len(val2)
          if python3 or type(val2) == unicode:
            val2 = val2.encode('utf-8')
            length = len(val2)
          buff.write(struct.pack('<I%ss'%length, length, val2))
        length = len(val1.substatuses)
        buff.write(_struct_I.pack(length))
        for val2 in val1.substatuses:
          buff.write(_get_struct_H().pack(val2.substatus))
          _x = val2.detail
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.pack('<I%ss'%length, length, _x))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    try:
      if self.header is None:
        self.header = std_msgs.msg.Header()
      if self.robot_to_camera_tf is None:
        self.robot_to_camera_tf = geometry_msgs.msg.TransformStamped()
      if self.camera_to_reference_tf is None:
        self.camera_to_reference_tf = geometry_msgs.msg.TransformStamped()
      if self.objects is None:
        self.objects = None
      end = 0
      _x = self
      start = end
      end += 12
      (_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs,) = _get_struct_3I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.header.frame_id = str[start:end].decode('utf-8')
      else:
        self.header.frame_id = str[start:end]
      _x = self
      start = end
      end += 17
      (_x.content, _x.encoder_stamp, _x.robot_to_camera_tf.header.seq, _x.robot_to_camera_tf.header.stamp.secs, _x.robot_to_camera_tf.header.stamp.nsecs,) = _get_struct_B4I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.robot_to_camera_tf.header.frame_id = str[start:end].decode('utf-8')
      else:
        self.robot_to_camera_tf.header.frame_id = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.robot_to_camera_tf.child_frame_id = str[start:end].decode('utf-8')
      else:
        self.robot_to_camera_tf.child_frame_id = str[start:end]
      _x = self
      start = end
      end += 68
      (_x.robot_to_camera_tf.transform.translation.x, _x.robot_to_camera_tf.transform.translation.y, _x.robot_to_camera_tf.transform.translation.z, _x.robot_to_camera_tf.transform.rotation.x, _x.robot_to_camera_tf.transform.rotation.y, _x.robot_to_camera_tf.transform.rotation.z, _x.robot_to_camera_tf.transform.rotation.w, _x.camera_to_reference_tf.header.seq, _x.camera_to_reference_tf.header.stamp.secs, _x.camera_to_reference_tf.header.stamp.nsecs,) = _get_struct_7d3I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.camera_to_reference_tf.header.frame_id = str[start:end].decode('utf-8')
      else:
        self.camera_to_reference_tf.header.frame_id = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.camera_to_reference_tf.child_frame_id = str[start:end].decode('utf-8')
      else:
        self.camera_to_reference_tf.child_frame_id = str[start:end]
      _x = self
      start = end
      end += 87
      (_x.camera_to_reference_tf.transform.translation.x, _x.camera_to_reference_tf.transform.translation.y, _x.camera_to_reference_tf.transform.translation.z, _x.camera_to_reference_tf.transform.rotation.x, _x.camera_to_reference_tf.transform.rotation.y, _x.camera_to_reference_tf.transform.rotation.z, _x.camera_to_reference_tf.transform.rotation.w, _x.cloud_capturing_duration, _x.clustering_method, _x.n_rejected_clusters, _x.clustering_duration, _x.calculation_time, _x.n_valid_objects, _x.n_rejected_objects,) = _get_struct_8dBH2d2H().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.objects = []
      for i in range(0, length):
        val1 = im_pickit_msgs.msg.Object()
        start = end
        end += 2
        (val1.index,) = _get_struct_H().unpack(str[start:end])
        _v21 = val1.object_tf
        _v22 = _v21.header
        start = end
        end += 4
        (_v22.seq,) = _get_struct_I().unpack(str[start:end])
        _v23 = _v22.stamp
        _x = _v23
        start = end
        end += 8
        (_x.secs, _x.nsecs,) = _get_struct_2I().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v22.frame_id = str[start:end].decode('utf-8')
        else:
          _v22.frame_id = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v21.child_frame_id = str[start:end].decode('utf-8')
        else:
          _v21.child_frame_id = str[start:end]
        _v24 = _v21.transform
        _v25 = _v24.translation
        _x = _v25
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
        _v26 = _v24.rotation
        _x = _v26
        start = end
        end += 32
        (_x.x, _x.y, _x.z, _x.w,) = _get_struct_4d().unpack(str[start:end])
        _v27 = val1.object_pick_tf
        _v28 = _v27.header
        start = end
        end += 4
        (_v28.seq,) = _get_struct_I().unpack(str[start:end])
        _v29 = _v28.stamp
        _x = _v29
        start = end
        end += 8
        (_x.secs, _x.nsecs,) = _get_struct_2I().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v28.frame_id = str[start:end].decode('utf-8')
        else:
          _v28.frame_id = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v27.child_frame_id = str[start:end].decode('utf-8')
        else:
          _v27.child_frame_id = str[start:end]
        _v30 = _v27.transform
        _v31 = _v30.translation
        _x = _v31
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
        _v32 = _v30.rotation
        _x = _v32
        start = end
        end += 32
        (_x.x, _x.y, _x.z, _x.w,) = _get_struct_4d().unpack(str[start:end])
        _v33 = val1.model
        start = end
        end += 1
        (_v33.type,) = _get_struct_B().unpack(str[start:end])
        start = end
        end += 2
        (val1.n_points,) = _get_struct_H().unpack(str[start:end])
        _v34 = val1.dimensions
        _x = _v34
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
        _v35 = val1.reliability
        _v36 = _v35.scene_coverage_2d
        _x = _v36
        start = end
        end += 17
        (_x.value, _x.required_value, _x.has_upper_limit,) = _get_struct_2dB().unpack(str[start:end])
        _v36.has_upper_limit = bool(_v36.has_upper_limit)
        _v37 = _v35.scene_coverage_3d
        _x = _v37
        start = end
        end += 17
        (_x.value, _x.required_value, _x.has_upper_limit,) = _get_struct_2dB().unpack(str[start:end])
        _v37.has_upper_limit = bool(_v37.has_upper_limit)
        _v38 = _v35.model_contour_coverage_2d
        _x = _v38
        start = end
        end += 17
        (_x.value, _x.required_value, _x.has_upper_limit,) = _get_struct_2dB().unpack(str[start:end])
        _v38.has_upper_limit = bool(_v38.has_upper_limit)
        _v39 = _v35.model_surface_coverage_2d
        _x = _v39
        start = end
        end += 17
        (_x.value, _x.required_value, _x.has_upper_limit,) = _get_struct_2dB().unpack(str[start:end])
        _v39.has_upper_limit = bool(_v39.has_upper_limit)
        _v40 = _v35.model_coverage_3d
        _x = _v40
        start = end
        end += 17
        (_x.value, _x.required_value, _x.has_upper_limit,) = _get_struct_2dB().unpack(str[start:end])
        _v40.has_upper_limit = bool(_v40.has_upper_limit)
        _x = val1
        start = end
        end += 3
        (_x.is_valid, _x.is_pickable, _x.is_detectable,) = _get_struct_3B().unpack(str[start:end])
        val1.is_valid = bool(val1.is_valid)
        val1.is_pickable = bool(val1.is_pickable)
        val1.is_detectable = bool(val1.is_detectable)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.categories = []
        for i in range(0, length):
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val2 = str[start:end].decode('utf-8')
          else:
            val2 = str[start:end]
          val1.categories.append(val2)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.substatuses = []
        for i in range(0, length):
          val2 = im_pickit_msgs.msg.SubStatus()
          start = end
          end += 2
          (val2.substatus,) = _get_struct_H().unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val2.detail = str[start:end].decode('utf-8')
          else:
            val2.detail = str[start:end]
          val1.substatuses.append(val2)
        self.objects.append(val1)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e) #most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self
      buff.write(_get_struct_3I().pack(_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs))
      _x = self.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_get_struct_B4I().pack(_x.content, _x.encoder_stamp, _x.robot_to_camera_tf.header.seq, _x.robot_to_camera_tf.header.stamp.secs, _x.robot_to_camera_tf.header.stamp.nsecs))
      _x = self.robot_to_camera_tf.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.robot_to_camera_tf.child_frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_get_struct_7d3I().pack(_x.robot_to_camera_tf.transform.translation.x, _x.robot_to_camera_tf.transform.translation.y, _x.robot_to_camera_tf.transform.translation.z, _x.robot_to_camera_tf.transform.rotation.x, _x.robot_to_camera_tf.transform.rotation.y, _x.robot_to_camera_tf.transform.rotation.z, _x.robot_to_camera_tf.transform.rotation.w, _x.camera_to_reference_tf.header.seq, _x.camera_to_reference_tf.header.stamp.secs, _x.camera_to_reference_tf.header.stamp.nsecs))
      _x = self.camera_to_reference_tf.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.camera_to_reference_tf.child_frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_get_struct_8dBH2d2H().pack(_x.camera_to_reference_tf.transform.translation.x, _x.camera_to_reference_tf.transform.translation.y, _x.camera_to_reference_tf.transform.translation.z, _x.camera_to_reference_tf.transform.rotation.x, _x.camera_to_reference_tf.transform.rotation.y, _x.camera_to_reference_tf.transform.rotation.z, _x.camera_to_reference_tf.transform.rotation.w, _x.cloud_capturing_duration, _x.clustering_method, _x.n_rejected_clusters, _x.clustering_duration, _x.calculation_time, _x.n_valid_objects, _x.n_rejected_objects))
      length = len(self.objects)
      buff.write(_struct_I.pack(length))
      for val1 in self.objects:
        buff.write(_get_struct_H().pack(val1.index))
        _v41 = val1.object_tf
        _v42 = _v41.header
        buff.write(_get_struct_I().pack(_v42.seq))
        _v43 = _v42.stamp
        _x = _v43
        buff.write(_get_struct_2I().pack(_x.secs, _x.nsecs))
        _x = _v42.frame_id
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = _v41.child_frame_id
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.pack('<I%ss'%length, length, _x))
        _v44 = _v41.transform
        _v45 = _v44.translation
        _x = _v45
        buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
        _v46 = _v44.rotation
        _x = _v46
        buff.write(_get_struct_4d().pack(_x.x, _x.y, _x.z, _x.w))
        _v47 = val1.object_pick_tf
        _v48 = _v47.header
        buff.write(_get_struct_I().pack(_v48.seq))
        _v49 = _v48.stamp
        _x = _v49
        buff.write(_get_struct_2I().pack(_x.secs, _x.nsecs))
        _x = _v48.frame_id
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = _v47.child_frame_id
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.pack('<I%ss'%length, length, _x))
        _v50 = _v47.transform
        _v51 = _v50.translation
        _x = _v51
        buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
        _v52 = _v50.rotation
        _x = _v52
        buff.write(_get_struct_4d().pack(_x.x, _x.y, _x.z, _x.w))
        _v53 = val1.model
        buff.write(_get_struct_B().pack(_v53.type))
        buff.write(_get_struct_H().pack(val1.n_points))
        _v54 = val1.dimensions
        _x = _v54
        buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.z))
        _v55 = val1.reliability
        _v56 = _v55.scene_coverage_2d
        _x = _v56
        buff.write(_get_struct_2dB().pack(_x.value, _x.required_value, _x.has_upper_limit))
        _v57 = _v55.scene_coverage_3d
        _x = _v57
        buff.write(_get_struct_2dB().pack(_x.value, _x.required_value, _x.has_upper_limit))
        _v58 = _v55.model_contour_coverage_2d
        _x = _v58
        buff.write(_get_struct_2dB().pack(_x.value, _x.required_value, _x.has_upper_limit))
        _v59 = _v55.model_surface_coverage_2d
        _x = _v59
        buff.write(_get_struct_2dB().pack(_x.value, _x.required_value, _x.has_upper_limit))
        _v60 = _v55.model_coverage_3d
        _x = _v60
        buff.write(_get_struct_2dB().pack(_x.value, _x.required_value, _x.has_upper_limit))
        _x = val1
        buff.write(_get_struct_3B().pack(_x.is_valid, _x.is_pickable, _x.is_detectable))
        length = len(val1.categories)
        buff.write(_struct_I.pack(length))
        for val2 in val1.categories:
          length = len(val2)
          if python3 or type(val2) == unicode:
            val2 = val2.encode('utf-8')
            length = len(val2)
          buff.write(struct.pack('<I%ss'%length, length, val2))
        length = len(val1.substatuses)
        buff.write(_struct_I.pack(length))
        for val2 in val1.substatuses:
          buff.write(_get_struct_H().pack(val2.substatus))
          _x = val2.detail
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.pack('<I%ss'%length, length, _x))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    try:
      if self.header is None:
        self.header = std_msgs.msg.Header()
      if self.robot_to_camera_tf is None:
        self.robot_to_camera_tf = geometry_msgs.msg.TransformStamped()
      if self.camera_to_reference_tf is None:
        self.camera_to_reference_tf = geometry_msgs.msg.TransformStamped()
      if self.objects is None:
        self.objects = None
      end = 0
      _x = self
      start = end
      end += 12
      (_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs,) = _get_struct_3I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.header.frame_id = str[start:end].decode('utf-8')
      else:
        self.header.frame_id = str[start:end]
      _x = self
      start = end
      end += 17
      (_x.content, _x.encoder_stamp, _x.robot_to_camera_tf.header.seq, _x.robot_to_camera_tf.header.stamp.secs, _x.robot_to_camera_tf.header.stamp.nsecs,) = _get_struct_B4I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.robot_to_camera_tf.header.frame_id = str[start:end].decode('utf-8')
      else:
        self.robot_to_camera_tf.header.frame_id = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.robot_to_camera_tf.child_frame_id = str[start:end].decode('utf-8')
      else:
        self.robot_to_camera_tf.child_frame_id = str[start:end]
      _x = self
      start = end
      end += 68
      (_x.robot_to_camera_tf.transform.translation.x, _x.robot_to_camera_tf.transform.translation.y, _x.robot_to_camera_tf.transform.translation.z, _x.robot_to_camera_tf.transform.rotation.x, _x.robot_to_camera_tf.transform.rotation.y, _x.robot_to_camera_tf.transform.rotation.z, _x.robot_to_camera_tf.transform.rotation.w, _x.camera_to_reference_tf.header.seq, _x.camera_to_reference_tf.header.stamp.secs, _x.camera_to_reference_tf.header.stamp.nsecs,) = _get_struct_7d3I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.camera_to_reference_tf.header.frame_id = str[start:end].decode('utf-8')
      else:
        self.camera_to_reference_tf.header.frame_id = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.camera_to_reference_tf.child_frame_id = str[start:end].decode('utf-8')
      else:
        self.camera_to_reference_tf.child_frame_id = str[start:end]
      _x = self
      start = end
      end += 87
      (_x.camera_to_reference_tf.transform.translation.x, _x.camera_to_reference_tf.transform.translation.y, _x.camera_to_reference_tf.transform.translation.z, _x.camera_to_reference_tf.transform.rotation.x, _x.camera_to_reference_tf.transform.rotation.y, _x.camera_to_reference_tf.transform.rotation.z, _x.camera_to_reference_tf.transform.rotation.w, _x.cloud_capturing_duration, _x.clustering_method, _x.n_rejected_clusters, _x.clustering_duration, _x.calculation_time, _x.n_valid_objects, _x.n_rejected_objects,) = _get_struct_8dBH2d2H().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.objects = []
      for i in range(0, length):
        val1 = im_pickit_msgs.msg.Object()
        start = end
        end += 2
        (val1.index,) = _get_struct_H().unpack(str[start:end])
        _v61 = val1.object_tf
        _v62 = _v61.header
        start = end
        end += 4
        (_v62.seq,) = _get_struct_I().unpack(str[start:end])
        _v63 = _v62.stamp
        _x = _v63
        start = end
        end += 8
        (_x.secs, _x.nsecs,) = _get_struct_2I().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v62.frame_id = str[start:end].decode('utf-8')
        else:
          _v62.frame_id = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v61.child_frame_id = str[start:end].decode('utf-8')
        else:
          _v61.child_frame_id = str[start:end]
        _v64 = _v61.transform
        _v65 = _v64.translation
        _x = _v65
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
        _v66 = _v64.rotation
        _x = _v66
        start = end
        end += 32
        (_x.x, _x.y, _x.z, _x.w,) = _get_struct_4d().unpack(str[start:end])
        _v67 = val1.object_pick_tf
        _v68 = _v67.header
        start = end
        end += 4
        (_v68.seq,) = _get_struct_I().unpack(str[start:end])
        _v69 = _v68.stamp
        _x = _v69
        start = end
        end += 8
        (_x.secs, _x.nsecs,) = _get_struct_2I().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v68.frame_id = str[start:end].decode('utf-8')
        else:
          _v68.frame_id = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v67.child_frame_id = str[start:end].decode('utf-8')
        else:
          _v67.child_frame_id = str[start:end]
        _v70 = _v67.transform
        _v71 = _v70.translation
        _x = _v71
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
        _v72 = _v70.rotation
        _x = _v72
        start = end
        end += 32
        (_x.x, _x.y, _x.z, _x.w,) = _get_struct_4d().unpack(str[start:end])
        _v73 = val1.model
        start = end
        end += 1
        (_v73.type,) = _get_struct_B().unpack(str[start:end])
        start = end
        end += 2
        (val1.n_points,) = _get_struct_H().unpack(str[start:end])
        _v74 = val1.dimensions
        _x = _v74
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _get_struct_3d().unpack(str[start:end])
        _v75 = val1.reliability
        _v76 = _v75.scene_coverage_2d
        _x = _v76
        start = end
        end += 17
        (_x.value, _x.required_value, _x.has_upper_limit,) = _get_struct_2dB().unpack(str[start:end])
        _v76.has_upper_limit = bool(_v76.has_upper_limit)
        _v77 = _v75.scene_coverage_3d
        _x = _v77
        start = end
        end += 17
        (_x.value, _x.required_value, _x.has_upper_limit,) = _get_struct_2dB().unpack(str[start:end])
        _v77.has_upper_limit = bool(_v77.has_upper_limit)
        _v78 = _v75.model_contour_coverage_2d
        _x = _v78
        start = end
        end += 17
        (_x.value, _x.required_value, _x.has_upper_limit,) = _get_struct_2dB().unpack(str[start:end])
        _v78.has_upper_limit = bool(_v78.has_upper_limit)
        _v79 = _v75.model_surface_coverage_2d
        _x = _v79
        start = end
        end += 17
        (_x.value, _x.required_value, _x.has_upper_limit,) = _get_struct_2dB().unpack(str[start:end])
        _v79.has_upper_limit = bool(_v79.has_upper_limit)
        _v80 = _v75.model_coverage_3d
        _x = _v80
        start = end
        end += 17
        (_x.value, _x.required_value, _x.has_upper_limit,) = _get_struct_2dB().unpack(str[start:end])
        _v80.has_upper_limit = bool(_v80.has_upper_limit)
        _x = val1
        start = end
        end += 3
        (_x.is_valid, _x.is_pickable, _x.is_detectable,) = _get_struct_3B().unpack(str[start:end])
        val1.is_valid = bool(val1.is_valid)
        val1.is_pickable = bool(val1.is_pickable)
        val1.is_detectable = bool(val1.is_detectable)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.categories = []
        for i in range(0, length):
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val2 = str[start:end].decode('utf-8')
          else:
            val2 = str[start:end]
          val1.categories.append(val2)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.substatuses = []
        for i in range(0, length):
          val2 = im_pickit_msgs.msg.SubStatus()
          start = end
          end += 2
          (val2.substatus,) = _get_struct_H().unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val2.detail = str[start:end].decode('utf-8')
          else:
            val2.detail = str[start:end]
          val1.substatuses.append(val2)
        self.objects.append(val1)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e) #most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_B = None
def _get_struct_B():
    global _struct_B
    if _struct_B is None:
        _struct_B = struct.Struct("<B")
    return _struct_B
_struct_8dBH2d2H = None
def _get_struct_8dBH2d2H():
    global _struct_8dBH2d2H
    if _struct_8dBH2d2H is None:
        _struct_8dBH2d2H = struct.Struct("<8dBH2d2H")
    return _struct_8dBH2d2H
_struct_H = None
def _get_struct_H():
    global _struct_H
    if _struct_H is None:
        _struct_H = struct.Struct("<H")
    return _struct_H
_struct_2I = None
def _get_struct_2I():
    global _struct_2I
    if _struct_2I is None:
        _struct_2I = struct.Struct("<2I")
    return _struct_2I
_struct_3I = None
def _get_struct_3I():
    global _struct_3I
    if _struct_3I is None:
        _struct_3I = struct.Struct("<3I")
    return _struct_3I
_struct_2dB = None
def _get_struct_2dB():
    global _struct_2dB
    if _struct_2dB is None:
        _struct_2dB = struct.Struct("<2dB")
    return _struct_2dB
_struct_3B = None
def _get_struct_3B():
    global _struct_3B
    if _struct_3B is None:
        _struct_3B = struct.Struct("<3B")
    return _struct_3B
_struct_4d = None
def _get_struct_4d():
    global _struct_4d
    if _struct_4d is None:
        _struct_4d = struct.Struct("<4d")
    return _struct_4d
_struct_B4I = None
def _get_struct_B4I():
    global _struct_B4I
    if _struct_B4I is None:
        _struct_B4I = struct.Struct("<B4I")
    return _struct_B4I
_struct_7d3I = None
def _get_struct_7d3I():
    global _struct_7d3I
    if _struct_7d3I is None:
        _struct_7d3I = struct.Struct("<7d3I")
    return _struct_7d3I
_struct_3d = None
def _get_struct_3d():
    global _struct_3d
    if _struct_3d is None:
        _struct_3d = struct.Struct("<3d")
    return _struct_3d
